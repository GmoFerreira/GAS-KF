# Importamos las librer√≠as
using Random
using LinearAlgebra
using DataFrames
using Plots
using Distributions
using NLopt
using SpecialFunctions
using StatsPlots

using CSV
using LaTeXStrings
using StatsBase
using CategoricalArrays
using RCall
using SparseArrays

function psi(d)
    Psi = zeros(1,171)
    Psi[1] = 1.0
    for j in 1:170
        Psi[j+1] = gamma(j+d)/(gamma(j+1)*gamma(d)) 
    end
    return Psi
end

# Matriz Ft
function sim_Ft(m::Int64)
    Ft = spdiagm(-1 => ones(m))
    return Ft
end

# Matriz Q
function sim_Qt(m::Int64)
    Qt = spzeros(m+1, m+1) 
    Qt[1,1] = 1.0
    return Qt
end


function Simular(n::Int64, œâ::Float64, A::Float64, B::Float64, d::Float64, seed::Int64)
    Random.seed!(seed)
    # Inicializamos
    Y = vec(zeros(n, 1))
    ùúÉ = vec(zeros(n, 1))
    ùúÉ[1] = 1.0
    
    # Ruido normal
    ùúÄ = rand(Normal(0, 1), n+170)
    
    # vector de psi_j
    Psi = psi(d)
    
    # t = 1
    Y[1,:] = Psi*ùúÄ[171:-1:1]
    st = -1 + Y[1]*ùúÄ[171]
    
    # t = 2
    ùúÉ[2] = œâ + A*st + B*ùúÉ[1]
    Gt = ùúÉ[2]*Psi
    
    Y[2,:] .=  Gt*ùúÄ[172:-1:2]
    
    for t in 2:(n-1)
        st = -(1/ùúÉ[t])+ (Y[t]*ùúÄ[t+170])/(ùúÉ[t])^2
        ùúÉ[t+1] = œâ + A*st + B*ùúÉ[t]
        Gt = ùúÉ[t+1]*Psi
        Y[t+1,:] = Gt*ùúÄ[t+171:-1:(t+1)]
    end
    return Dict(:Y => Y, :ùúÉ => ùúÉ)
end

######### Kalman Filter

function KalmanOF_TVFI(P::Vector{Float64}, grad::Union{Nothing, Vector{Float64}}, Psi, Y::Vector{Float64}, n::Int64, m::Int64,
    Ft::Union{Matrix{Float64},SparseMatrixCSC{Float64, Int64}}, Qt::Union{Matrix{Float64},SparseMatrixCSC{Float64, Int64}})
    
    œâ = P[1]; A = P[2]; B = P[3]; d = P[4]
    Ft = sim_Ft(m)
    Œ©t = sim_Qt(m)
  
    # primera iteraci√≥n
    vt = Y[1]
    ùúÉt = 1.0
    ‚àÜt = 1.0
    inv‚àÜt = ‚àÜt^(-1)
    L = (1/2)*(log(‚àÜt)+vt^2*inv‚àÜt)
    Gt = Psi
    dGt = Psi' # este es constante
    
    Xtt = Œ©t*Gt'*inv‚àÜt*vt
    
    d‚àÜt = (Gt*Œ©t)*dGt
    
    s1 = d‚àÜt'*inv‚àÜt^2*(vt^2-‚àÜt)
    
    ùúÉt = œâ + A*s1[1] + B*ùúÉt
    
    Gt = ùúÉt*Psi
    hatX = Ft*Xtt
    
    ‚àÜt = (Gt*Œ©t*Gt')[1]
    inv‚àÜt = ‚àÜt^(-1)

    hatY = Gt*hatX
    vt = Y[2]-hatY[1]
    L += (1/2)*(log(‚àÜt)+vt^2*inv‚àÜt)
    for t in 2:(n-1)
        Xtt = hatX + Œ©t*Gt'*inv‚àÜt*vt
        d‚àÜt = (Gt*Œ©t)*dGt
        dvt = -hatX'*dGt
        st = d‚àÜt'*inv‚àÜt^2*(vt^2-‚àÜt).- dvt*inv‚àÜt*vt
        ùúÉt = œâ + A*st[1] + B*ùúÉt

        Gt = ùúÉt*Psi
        ‚àÜt = (Gt*Œ©t*Gt')[1]
        inv‚àÜt = ‚àÜt^(-1)

        hatX = Ft*Xtt
        hatY = Gt*hatX
        vt = Y[t+1]-hatY[1]
        L += (1/2)*(log(‚àÜt)+vt^2*inv‚àÜt)
    end
return L
end

#####¬†Function to estimate the parameters

function EstimacionMV(Pi::Vector{Float64}, Pm::Vector{Float64}, PM::Vector{Float64}, Y::Vector{Float64}, n::Int64, m::Int64)
    Ft = sim_Ft(m)
    Qt = sim_Qt(m)
    Psi = psi(d)[:,1:m+1]
    opt = Opt(:LN_BOBYQA, length(Pi))
    lower_bounds!(opt, Pm)
    upper_bounds!(opt, PM)
    min_objective!(opt, (Pi, grad) -> KalmanOF_TVFI(Pi, grad, Psi, Y, n, m, Ft, Qt))
    maxeval!(opt, 700) 
    
    (NLV, P_opt, status) = optimize(opt, Pi)
    return Dict("Par√°metros" => P_opt, "Log-Verosimilitud" => -NLV)
end

# Par√°metros Escenario 1
œâr1 = 0.6; Ar1 = 0.7; Br1 = 0.8; dr1 = 0.3
Pr1 = [œâr1;Ar1;Br1;dr1]
# Valores iniciales
Pi1 = [0.5;0.65;0.7;0.3]

# Par√°metros Escenario 2
œâr2 = 1.0; Ar2 = 0.6; Br2 = 0.75; dr2 = 0.4
Pr2 = [œâr2;Ar2;Br2;dr2]

# Valores iniciales
Pi2 = [0.95;0.65;0.7;0.4]

# Par√°metros M√≠nimos y m√°ximos
Pm1 = [œâr1-œâr1*0.5, Ar1-Ar1*0.5, Br1-Br1*0.5, dr1-dr1*0.5]
PM1 = [œâr1+œâr1*0.5, Ar1+Ar1*0.4, 0.99, dr1+dr1*0.5]

Pm2 = [œâr2-œâr2*0.5, Ar2-Ar2*0.5, Br2-Br2*0.5, dr2-dr2*0.5]
PM2 = [œâr2+œâr2*0.5, Ar2+Ar2*0.4, 0.99, dr2+dr2*0.5]

######### Start of the simulation study ############################### 
N = 1000; n = 1000; m = 10
# Matrices que contengan las estimaciones por MV de cada escenario
auxMV1 = zeros(N, 4)
auxMV2 = zeros(N, 4)

@time for i in 1:N
    ########## Escenario 1 ########## 
    Sim1 = Simular(n, œâr1, Ar1, Br1, dr1,i)
    YR1 = vec(Sim1[:Y])
    Œ∏R1 = vec(Sim1[:ùúÉ])

    EstimacionP1 = EstimacionMV(Pi1, Pm1, PM1, YR1, n, m)
    hatP1 = EstimacionP1[:"Par√°metros"]
    auxMV1[i,:] .= hatP1
    
    ########## Escenario 2 ########## 
    Sim2 = Simular(n, œâr2, Ar2, Br2, dr2, i)
    YR2 = vec(Sim2[:Y])
    Œ∏R2 = vec(Sim2[:ùúÉ])

    EstimacionP2 = EstimacionMV(Pi2, Pm2, PM2, YR2, n, m)
    hatP2 = EstimacionP2[:"Par√°metros"]
    auxMV2[i,:] .= hatP2
end

Estimaciones1_1 = auxMV1
Estimaciones1_2 = auxMV2
println("Termin√≥")


println("------------------------------------------------")
println("Resumen de Estimaci√≥n de Par√°metros Escenario 1:")
println("œâ = 0.6; A = 0.7; B = 0.8; d = 0.3")
println("------------------------------------------------")
R"""
print(summary($Estimaciones1_1[,1]))
print(summary($Estimaciones1_1[,2]))
print(summary($Estimaciones1_1[,3]))
print(summary($Estimaciones1_1[,4]))
"""
println("------------------------------------------------")


println("------------------------------------------------")
println("Resumen de Estimaci√≥n de Par√°metros Escenario 1:")
println("œâ = 1.0; A = 0.6; B = 0.75; d = 0.4")
println("------------------------------------------------")
R"""
print(summary($Estimaciones1_2[,1]))
print(summary($Estimaciones1_2[,2]))
print(summary($Estimaciones1_2[,3]))
print(summary($Estimaciones1_2[,4]))
"""
println("------------------------------------------------")




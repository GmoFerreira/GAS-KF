# Importamos las librerÃ­as
using Random
using LinearAlgebra
using DataFrames
using Plots
using Distributions
using NLopt
using SpecialFunctions
using StatsPlots

using CSV
using LaTeXStrings
using StatsBase
using CategoricalArrays
using RCall

## Simulation function

function ARGAS1(n::Int64, Ïƒ::Float64, Ï‰::Float64, A::Float64, B::Float64, seed::Int64)
    Random.seed!(seed)
    # Inicializamos los vectores
    Y = zeros(n, 1)
    Î¸ = zeros(n, 1)

    # Ruido multivariado normal
    ðœ‰ = rand(Normal(0, Ïƒ), n)

    # Condiciones iniciales
    Î¸[1] = 0
    Y[1] = ðœ‰[1]
    s1 = 0
    
    # Valores Futuros del vector de parÃ¡metros
    Î¸[2] = Ï‰ + A*s1 + B*Î¸[1]
    Y[2] = Î¸[2]*Y[1] + ðœ‰[2]

    for t in 2:(n-1)
        st = sign(Y[t-1])*ðœ‰[t]/abs(Ïƒ)
        Î¸[t+1] = Ï‰ + A*st + B*Î¸[t]
        Y[t+1] = Î¸[t+1]*Y[t] + ðœ‰[t+1]
    end
    return Dict(:Y => Y, :Î¸ => Î¸)
end

### Function to create the vector G_t

function G_t2(t::Int64, hatÎ¸::Vector{Float64}, m::Int64)
    Gt = zeros(1, m+1)
    Gt[1] = 1
    
    if t == 1
        return Gt
    end
    prod_ = 1.0
    if t < m
        for k in 0:(t-2)
            prod_ *= hatÎ¸[t-k]
            Gt[k+2] = prod_
        end
    else
        for k in 0:(m-1)
            prod_ *= hatÎ¸[t-k]
            Gt[k+2] = prod_
        end
    end
    return Gt
end

### Function to create the derivative vector of G_t

function dG_t2(t::Int64, hatÎ¸::Vector{Float64}, m::Int64)
    dGt = zeros(m+1) 
    if t == 1
        return dGt
    end
    dGt[2] = 1.0
    if t == 2
        return dGt
    end
    prod_v = 1.0
    if t < m
        for k in 1:(t-2)
            prod_v *= hatÎ¸[t-k]
            dGt[k+2] = prod_v
        end
    else
        for k in 1:(m-1)
            prod_v *= hatÎ¸[t-k]
            dGt[k+2] = prod_v
        end
    end
    return dGt
end

##### Kalaman Filter algorithm 

function TVMA_KalmanOF2(P::Vector{Float64}, grad::Union{Nothing, Vector{Float64}},Y::Vector{Float64}, n::Int64, m::Int64,
    Ft::Matrix{Float64}, Qt::Matrix{Float64})
    Ï‰ = P[1]; A = P[2]; B = P[3]; Ïƒ = P[4]
    # InicializaciÃ³n de matrices
    hatÎ¸ = zeros(1,n)
    LL = zeros(1,n)
    invâˆ†t = (Ïƒ^2)^(-1)
    Gt = G_t2(1, vec(hatÎ¸), m)

    Qt[1,1] = Ïƒ^2 
    Î© = Ïƒ^2*I(m+1) #Matrix{Float64}(I, m+1, m+1)
    v = Y[1]
    LL[1] = (1/2)*(v^2)

    # Primera iteraciÃ³n
    Xtt = Î©*Gt'*invâˆ†t*v
    dGt = dG_t2(1, vec(hatÎ¸), m)
    
    s1 = 0
    hatÎ¸[2] = Ï‰ + A*s1 + B*hatÎ¸[1]
     
    Gt = G_t2(2, vec(hatÎ¸), m)
    hatX = Ft*Xtt
    hatY = Gt*hatX
    
    Theta = Ft*Î©*Gt'
    Î© = Ft*Î©*Ft' + Qt-Theta*invâˆ†t*Theta'
    v = Y[2]-hatY[1]
    
    LL[2] = (1/2)*(v^2)
    
    for t in 2:(n-1)
        Xtt = hatX + Î©*Gt'*invâˆ†t*v
        dGt = dG_t2(t, vec(hatÎ¸), m)
        dvt = -hatX'*dGt
        if norm(dvt) > 0.0
            âˆ‡t = -dvt*invâˆ†t*v
            It = dvt.^2*invâˆ†t
            st = It.^(-1/2).*âˆ‡t
        else
            st = 0
        end
        hatÎ¸[:,t+1] .= Ï‰ .+ A*st .+ B*hatÎ¸[:,t]
        Gt = G_t2(t+1, vec(hatÎ¸), m)
        
        if t<=m
            Theta = Ft*Î©*Gt'
            Î© = Ft*Î©*Ft' + Qt - Theta*invâˆ†t*Theta'
        elseif t==m+1
            Î© = Qt
        end
        
        hatX = Ft*Xtt
        hatY = Gt*hatX
        v = Y[t+1] - hatY[1]
        LL[t+1] = (1/2)*(v^2)
    end
    LL2 = sum(LL)
    return n*log(Ïƒ)+ LL2*invâˆ†t
end

### function to obtain the score-driven-KF estimators

function EstimacionMV(Pi::Vector{Float64}, Pm::Vector{Float64}, PM::Vector{Float64}, Y::Vector{Float64}, n::Int64, m::Int64)
    Ft = [zeros(1,m) 0;Matrix{Float64}(I, m, m) zeros(m,1)]
    Qt = zeros(m+1,m+1)
    opt = Opt(:LN_BOBYQA, length(Pi))
    lower_bounds!(opt, Pm)
    upper_bounds!(opt, PM)
    min_objective!(opt, (Pi, grad) -> TVMA_KalmanOF2(Pi, grad, Y, n, m, Ft, Qt))
    maxeval!(opt, 800)  # Limita las evaluaciones
    # Resolver el problema
    (NLV, P_opt, status) = optimize(opt, Pi)
    return Dict("ParÃ¡metros" => P_opt, "Log-Verosimilitud" => -NLV)
end

#### simulation study

 ParÃ¡metros Escenario 1
Ï‰r1 = 0.05; Ar1 = 0.2; Br1 = 0.3; Ïƒr1 = 2.0
Pr1 = [Ï‰r1;Ar1;Br1;Ïƒr1]
# Valores iniciales
Pi1 = [0.03;0.15;0.4;1.0]

# ParÃ¡metros Escenario 2
Ï‰r2 = 0.15; Ar2 = 0.3; Br2 = 0.15; Ïƒr2 = 1.0
Pr2 = [Ï‰r2;Ar2;Br2;Ïƒr2]
# Valores iniciales
Pi2 = [0.1;0.15;0.2;1.5]

# ParÃ¡metros Escenario 3
Ï‰r3 = 0.1; Ar3 = 0.15; Br3 = 0.2; Ïƒr3 = 1.5
Pr3 = [Ï‰r3;Ar3;Br3;Ïƒr3]
# Valores iniciales
Pi3 = [0.05;0.1;0.1;1.0]

# ParÃ¡metros MÃ­nimos y mÃ¡ximos
Pm1 = [0.4*Ï‰r1, Ar1*0.4, 0.4*Br1,0.4*Ïƒr1]
PM1 = [1.6*Ï‰r1, Ar1*1.6, 1.6*Br1,1.6*Ïƒr1]

Pm2 = [0.4*Ï‰r2, 0.4*Ar2, 0.4*Br2,0.4*Ïƒr2]
PM2 = [1.6*Ï‰r2, 1.6*Ar2, 1.6*Br2,1.6*Ïƒr2]

Pm3 = [0.4*Ï‰r3, 0.4*Ar3, 0.4*Br3,0.4*Ïƒr3]
PM3 = [1.6*Ï‰r3, 1.6*Ar3, 1.6*Br3,1.6*Ïƒr3]

############################### Inicio del estudio ############################### 
N = 1000; n = 1000; m = 10
# Matrices que contengan las estimaciones por MV de cada escenario
auxMV1 = zeros(N, 4)
auxMV2 = zeros(N, 4)
auxMV3 = zeros(N, 4)

@time for i in 1:N    
    ########## Escenario 1 ########## 
    Sim1 = ARGAS1(n, Ïƒr1, Ï‰r1, Ar1, Br1, 1000+i)
    YR1 = vec(Sim1[:Y])
    Î¸R1 = vec(Sim1[:Î¸])

    EstimacionP1 = EstimacionMV(Pi1, Pm1, PM1, YR1, n, m)
    hatP1 = EstimacionP1[:"ParÃ¡metros"]
    auxMV1[i,:] .= hatP1
    
    ########## Escenario 2 ########## 
    # Simulacion con los parÃ¡metros del escenerario 2
    Sim2 = ARGAS1(n, Ïƒr2, Ï‰r2, Ar2, Br2, i)
    YR2 = vec(Sim2[:Y])
    Î¸R2 = vec(Sim2[:Î¸])
    
    EstimacionP2 = EstimacionMV(Pi2, Pm2, PM2, YR2, n, m)
    hatP2 = EstimacionP2[:"ParÃ¡metros"]
    auxMV2[i,:] .= hatP2 
    
    ########## Escenario 3 ########## 
    # Simulacion con los parÃ¡metros del escenerario 2
    Sim3 = ARGAS1(n, Ïƒr3, Ï‰r3, Ar3, Br3, i)
    YR3 = vec(Sim3[:Y])
    Î¸R3 = vec(Sim3[:Î¸])
    
    EstimacionP3 = EstimacionMV(Pi3, Pm3, PM3, YR3, n, m)
    hatP3 = EstimacionP3[:"ParÃ¡metros"]
    auxMV3[i,:] .= hatP3 
end

Estimaciones1_1 = auxMV1
Estimaciones1_2 = auxMV2
Estimaciones1_3 = auxMV3
println("TerminÃ³")

######################### boxplot #########################
# CÃ¡lculo de errores relativos
Par11_C1 = (Ï‰r1 .- Estimaciones1_1[:, 1])./Ï‰r1
Par21_C1 = (Ar1 .- Estimaciones1_1[:, 2])./Ar1
Par31_C1 = (Br1 .- Estimaciones1_1[:, 3])./Br1
Par41_C1 = (Ïƒr1 .- Estimaciones1_1[:, 4])./Ïƒr1

datMV1 = hcat(Par11_C1, Par21_C1, Par31_C1, Par41_C1)

p1 = boxplot(
    [datMV1[:, 1] datMV1[:, 2] datMV1[:, 3] datMV1[:, 4]],
    legend=false,
    xlabel="",
    ylabel="Error Relativo",
    xticks=(1:4,  [L"$\omega$", L"$A$", L"$B$", L"$\sigma$"]),
    ylims=(-1.5, 1.5),
    fillalpha=1,
    title="Escenario 1",
    outliers=false,
    ygrid = true,              
    ygridalpha = 0.5,         
    ygridstyle = :dash,        
    yminorgrid = true,          
    yminorgridalpha = 0.2,     
    yminorgridstyle = :dash,
    guidefont = 10,
    fill = :white,
    linecolor=[:red :darkorange  :teal :darkmagenta],
    titlefont=16,
    frame=:box,
    framestyle=:frame,
    ytickfont = font(7),
    xtickfont = font(11) 
    )
# Organizar los grÃ¡ficos en un panel
boxplot1 = plot(p1)
display(boxplot1)


######################### boxplot #########################
# CÃ¡lculo de errores relativos
Par11_C1 = (Ï‰r2 .- Estimaciones1_2[:, 1])./Ï‰r2
Par21_C1 = (Ar2 .- Estimaciones1_2[:, 2])./Ar2
Par31_C1 = (Br2 .- Estimaciones1_2[:, 3])./Br2
Par41_C1 = (Ïƒr2 .- Estimaciones1_2[:, 4])./Ïƒr2

datMV1 = hcat(Par11_C1, Par21_C1, Par31_C1, Par41_C1)

p1 = boxplot(
    [datMV1[:, 1] datMV1[:, 2] datMV1[:, 3] datMV1[:, 4]],
    legend=false,
    xlabel="",
    ylabel="Error Relativo",
    xticks=(1:4,  [L"$\omega$", L"$A$", L"$B$", L"$\sigma$"]),
    ylims=(-1.5, 1.5),
    fillalpha=1,
    title="Escenario 2",
    outliers=false,
    ygrid = true,              
    ygridalpha = 0.5,         
    ygridstyle = :dash,        
    yminorgrid = true,          
    yminorgridalpha = 0.2,     
    yminorgridstyle = :dash,
    guidefont = 10,
    fill = :white,
    linecolor=[:red :darkorange  :teal :darkmagenta],
    titlefont=16,
    frame=:box,
    framestyle=:frame,
    ytickfont = font(7),
    xtickfont = font(11) 
    )
# Organizar los grÃ¡ficos en un panel
boxplot1 = plot(p1)
display(boxplot1)

######################### boxplot #########################
# CÃ¡lculo de errores relativos
Par11_C1 = (Ï‰r3 .- Estimaciones1_3[:, 1])./Ï‰r3
Par21_C1 = (Ar3 .- Estimaciones1_3[:, 2])./Ar3
Par31_C1 = (Br3 .- Estimaciones1_3[:, 3])./Br3
Par41_C1 = (Ïƒr3 .- Estimaciones1_3[:, 4])./Ïƒr3

datMV1 = hcat(Par11_C1, Par21_C1, Par31_C1, Par41_C1)

p1 = boxplot(
    [datMV1[:, 1] datMV1[:, 2] datMV1[:, 3] datMV1[:, 4]],
    legend=false,
    xlabel="",
    ylabel="Error Relativo",
    xticks=(1:4,  [L"$\omega$", L"$A$", L"$B$", L"$\sigma$"]),
    ylims=(-1.5, 1.5),
    fillalpha=1,
    title="Escenario 3",
    outliers=false,
    ygrid = true,              
    ygridalpha = 0.5,         
    ygridstyle = :dash,        
    yminorgrid = true,          
    yminorgridalpha = 0.2,     
    yminorgridstyle = :dash,
    guidefont = 10,
    fill = :white,
    linecolor=[:red :darkorange  :teal :darkmagenta],
    titlefont=16,
    frame=:box,
    framestyle=:frame,
    ytickfont = font(7),
    xtickfont = font(11) 
    )
# Organizar los grÃ¡ficos en un panel
boxplot1 = plot(p1)
display(boxplot1)

rintln("------------------------------------------------")
println("Resumen de EstimaciÃ³n de ParÃ¡metros Escenario 1:")
println("Ï‰ = 0.05; A = 0.2; B = 0.3; Ïƒ = 2.0")
println("------------------------------------------------")
R"""
print(summary($Estimaciones1_1[,1]))
print(summary($Estimaciones1_1[,2]))
print(summary($Estimaciones1_1[,3]))
print(summary($Estimaciones1_1[,4]))
"""
println("------------------------------------------------")


println("------------------------------------------------")
println("Resumen de EstimaciÃ³n de ParÃ¡metros Escenario 2:")
println("Ï‰ = 0.15; A = 0.3; B = 0.15; Ïƒ = 1.0")
println("------------------------------------------------")
R"""
print(summary($Estimaciones1_2[,1]))
print(summary($Estimaciones1_2[,2]))
print(summary($Estimaciones1_2[,3]))
print(summary($Estimaciones1_2[,4]))
"""
println("------------------------------------------------")


println("------------------------------------------------")
println("Resumen de EstimaciÃ³n de ParÃ¡metros Escenario 3:")
println("Ï‰ = 0.1; A = 0.15; B = 0.2; Ïƒ = 1.5")
println("------------------------------------------------")
R"""
print(summary($Estimaciones1_3[,1]))
print(summary($Estimaciones1_3[,2]))
print(summary($Estimaciones1_3[,3]))
print(summary($Estimaciones1_3[,4]))
"""
println("------------------------------------------------")

SD de las estimaciones
println("------ Escenario 1 ------")
println("Ï‰: ",std(Estimaciones1_1[:, 1]))
println("A: ",std(Estimaciones1_1[:, 2]))
println("B: ",std(Estimaciones1_1[:, 3]))
println("Ïƒ: ",std(Estimaciones1_1[:, 4]))
println("------ Escenario 2 ------")
println("Ï‰: ",std(Estimaciones1_2[:, 1]))
println("A: ",std(Estimaciones1_2[:, 2]))
println("B: ",std(Estimaciones1_2[:, 3]))
println("Ïƒ: ",std(Estimaciones1_2[:, 4]))
println("------ Escenario 3 ------")
println("Ï‰: ",std(Estimaciones1_3[:, 1]))
println("A: ",std(Estimaciones1_3[:, 2]))
println("B: ",std(Estimaciones1_3[:, 3]))
println("Ïƒ: ",std(Estimaciones1_3[:, 4]))

Real bias

println("------ Escenario 1 ------")
println("Ï‰: ",mean(Estimaciones1_1[:, 1] .- Ï‰r1))
println("A: ",mean(Estimaciones1_1[:, 2] .- Ar1))
println("B: ",mean(Estimaciones1_1[:, 3] .- Br1))
println("Ïƒ: ",mean(Estimaciones1_1[:, 4] .- Ïƒr1))

println("------ Escenario 2 ------")
println("Ï‰: ",mean(Estimaciones1_2[:, 1] .- Ï‰r2))
println("A: ",mean(Estimaciones1_2[:, 2] .- Ar2))
println("B: ",mean(Estimaciones1_2[:, 3] .- Br2))
println("Ïƒ: ",mean(Estimaciones1_2[:, 4] .- Ïƒr2))

println("------ Escenario 3 ------")
println("Ï‰: ",mean(Estimaciones1_3[:, 1] .- Ï‰r3))
println("A: ",mean(Estimaciones1_3[:, 2] .- Ar3))
println("B: ",mean(Estimaciones1_3[:, 3] .- Br3))
println("Ïƒ: ",mean(Estimaciones1_3[:, 4] .- Ïƒr3))

sqrt(Mean square error)

println("------ Escenario 1 ------")
println("Ï‰: ",sqrt(sum(Estimaciones1_1[:, 1].- Ï‰r1)^2/N))
println("A: ",sqrt(sum(Estimaciones1_1[:, 2].- Ar1)^2/N))
println("B: ",sqrt(sum(Estimaciones1_1[:, 3].- Br1)^2/N))
println("Ïƒ: ",sqrt(sum(Estimaciones1_1[:, 4].- Ïƒr1)^2/N))

println("------ Escenario 2 ------")
println("Ï‰: ",sqrt(sum(Estimaciones1_2[:, 1].- Ï‰r2)^2/N))
println("A: ",sqrt(sum(Estimaciones1_2[:, 2].- Ar2)^2/N))
println("B: ",sqrt(sum(Estimaciones1_2[:, 3].- Br2)^2/N))
println("Ïƒ: ",sqrt(sum(Estimaciones1_2[:, 4].- Ïƒr2)^2/N))

println("------ Escenario 3 ------")
println("Ï‰: ",sqrt(sum(Estimaciones1_3[:, 1].- Ï‰r3)^2/N))
println("A: ",sqrt(sum(Estimaciones1_3[:, 2].- Ar3)^2/N))
println("B: ",sqrt(sum(Estimaciones1_3[:, 3].- Br3)^2/N))
println("Ïƒ: ",sqrt(sum(Estimaciones1_3[:, 4].- Ïƒr3)^2/N))
